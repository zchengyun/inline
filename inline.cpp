/*
为什么使用内联函数？
       函数调用在执行时，首先要在栈中为形参和局部变量分配存储空间，然后还要将实参的值复制给形参，接下来还要将函数的返回地址
       （该地址指明了函数执行结束后，程序应该回到哪里继续执行）放入栈中，最后才跳转到函数内部执行。这个过程是要耗费时间的。

       另外，函数执行 return 语句返回时，需要从栈中回收形参和局部变量占用的存储空间，然后从栈中取出返回地址，再跳转到该地址
       继续执行，这个过程也要耗费时间。

       一般情况上述条件可以忽略，但是如果函数中语句少，执行时间很短并且使用频率非常高，这个时间消耗就不可忽略了。

内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处。

内联函数限制条件？
      (1) 不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即自己内部还调用自己的函数）。
      (2) 而所有（除了几乎什么也没做）的虚拟函数，因为virtual意味着”等待，直到执行时期再确定应该调用哪一个函数“，而inline却意味着”在编译
      阶段，将调用动作以被调用函数的主体取代之“。
*/
#include <iostream>
inline std::string judge(double a) {
    return a > 100. ? "大于100" : "不大于100";
}

int main()
{
    for (double i = 0; i < 1000; i = i + 50) {
        std::cout << i << judge(i) << std::endl;
    }
}

